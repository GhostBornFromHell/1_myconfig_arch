export LS_COLORS="$LS_COLORS:ow=30;44:"
export LS_OPTIONS=(--color=auto --group-directories-first )
export LESS_TERMCAP_mb=$'\e[1;31m'
export LESS_TERMCAP_md=$'\e[1;36m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;32m'
export LESS_TERMCAP_ue=$'\e[0m'


alias pacman='echo "    " && cowsay " utilise yay lol "'
alias pacwoman='sudo \pacman'
alias c='clear'

alias ls='ls $LS_OPTIONS'
alias l='ls $LS_OPTIONS -l'
alias ll='ls $LS_OPTIONS -la'
alias la='ls $LS_OPTIONS -A'

alias ffind='find . -type f -name'
alias dfind='find . -type d -name'

alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias diff='diff --color=auto'
alias ip='ip --color=auto'
alias nmrestart='sudo systemctl restart NetworkManager'
alias myco='nmcli device show'

alias poukicpu='ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head -20'
alias poukimem='ps -eo pid,comm,%cpu,%mem --sort=-%mem | head -20'
alias respire='vmstat 1'
alias panic='sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches'

alias els='eza --icons -h --group-directories-first'
alias el='eza --icons -lh --group-directories-first'
alias ell='eza --icons -lah --group-directories-first'
alias ela='eza --icons -Ah --group-directories-first'

alias a..='cd /'
alias 1..='cd ..'
alias 2..='cd ../..'
alias 3..='cd ../../..'

alias 755='chmod 755'
alias 700='chmod 700'
alias 600='chmod 600'
alias c+x='chmod +x'

alias py3w='python3 -m http.server'
alias py2w='python -m SimpleHTTPServer'
alias serve='python -m SimpleHTTPServer'

alias icat='kitten icat'

alias ok="echo oküå∏üå∏üå∏üå∏üå∏üå∏üå∏üå∏üå∏üå∏üå∏üå∏"
alias ko="echo koüò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠üò≠"
alias beep='echo -e "\a"'

alias parle='espeak-ng -v fr+f2 -s 140 -p 100'

alias ssh='TERM=xterm-256color ssh'

# need lynx
alias getlinks='lynx -dump -nonumbers -list_decoded -listonly -hiddenlinks=listonly -unique_urls'
alias getsource='lynx -source'
alias getcontent='lynx -dump -nonumbers -nolist'

hog() {
    # info system
    watch -n1 "ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head -n 10; free -h; echo 'Swap in/out:'; vmstat 1 2 | tail -n1"
}

cf() {
    # clear file faster
    [[ -z "$1" ]] && { echo "Usage: cf <fichier>"; return 1; }
    echo 0 > "$1"
    echo "ok"
    cat "$1"
}

add() {
    # add new ligne in file faster
    [[ -z "$1" ]] && { echo "Usage: add <content> <fichier>"; return 1; }
    echo "$1" >> "$2"
    echo "ok"
    cat "$2"
}

noleak() {
    # anti leak cat
    echo "\n\n\n\n\n\n\n\n\n\n\n\n\n"
    if [[ -z "$2" ]]; then
    "$1"
    else
        if [[ -z "$3" ]]; then
            "$1" "$2"
        else
            "$1" "$2" "$3"
        fi
    fi
    echo "\n\n\n\n\n\n\n\n\n\n\n\n\n"
}

gitwhoami() {
    # Nom et email Git
    local name email
    name=$(git config user.name)
    email=$(git config user.email)

    # Remote
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null)

    # Affichage joli et clair
    echo "üíª Git Identity:"
    echo "   Name  : $name"
    echo "   Email : $email"
    if [[ -n "$remote_url" ]]; then
        echo "   Remote: $remote_url"
    else
        echo "   Remote: (aucun origin configur√©)"
    fi
}

ghupdates() {
    # met a jour sur le compte lier a gh
    git config user.name "$G1_NAME"
    git config user.email "$G1_EMAIL"

    git add .
    git commit -m "New updates"
    git push
     
}

ghnew() {
    # creer un repo pour le compte lier a gh
    REPO_NAME="$1"
    REPO_VISIBILITY="$2"

    if [[ -z "$REPO_NAME" || -z "$REPO_VISIBILITY" ]]; then
        echo "Usage: ghnew <nom_du_repo> <public/private>"
        return 1
    fi

    if [[ "$REPO_VISIBILITY" != "public" && "$REPO_VISIBILITY" != "private" ]]; then
        echo "Valeur invalide. Utilise public ou private."
        return 1
    fi

    # Initialiser le d√©p√¥t si ce n‚Äôest pas d√©j√† fait
    if [[ ! -d ".git" ]]; then
        git init
    fi
    
    echo "# New repo open" > README.md || ko
    git config user.name "$G1_NAME"
    git config user.email "$G1_EMAIL"

    git add .
    git commit -m "New repo open"

    # Cr√©er le repo GitHub et push
    gh repo create "$REPO_NAME" --"$REPO_VISIBILITY" --source=. --push
}


ghostupdate() {

    # Configurer le user Ghost
    git config user.name "$G2_NAME"
    git config user.email "$G2_EMAIL"

    # Ajouter tous les fichiers et commit
    git add .
    git commit -m "${1:-New updates}" # message par d√©faut si pas pass√© en param

    # Assurer que le remote existe
    if ! git remote | grep -q "^origin$"; then
        echo "Erreur : remote 'origin' introuvable. Utilise ghostinit d'abord."
        return 1
    fi

    # Pousser vers Ghost
    git push -u origin main
}

ghostinit() {
    # github init pour ghost user
    REPO_NAME="$1"

    if [[ -z "$REPO_NAME" ]]; then
        echo "Usage: ghostinit <nom_du_repo>"
        return 1
    fi


    # Initialiser le d√©p√¥t
    git init

    # Configurer le user Ghost
    git config user.name "$G2_NAME"
    git config user.email "$G2_EMAIL"

    # Cr√©er README et commit initial
    echo "# new repo open" > README.md
    git add .
    git commit -m "Initial commit"

    # Ajouter remote Ghost
    git remote add origin "$G2_REMOTE$REPO_NAME".git

    # Pousser initial
    git push -u origin main
}

pseudogn2() {
    # nouvel version de pseudogn
    local mask="$1"
    local len="${#mask}"

    # longueur du pr√©fixe fixe (avant les @ ,)
    local prefix_len
    prefix_len=$(echo "$mask" | sed 's/[@,].*//; s/././g' | wc -c)
    prefix_len=$((prefix_len - 1))

    crunch "$len" "$len" abcdefghijklmnopqrstuvwxyz -t "$mask" \
    | grep -Ev '(.)\1\1' \
    | awk -v p="$prefix_len" '
        {
            part = substr($0, p+1)
            if (part ~ /^[bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXyYzZ][aAeEiIoOuUyY][bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXyYzZ]/ || part ~ /^[^bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXyYzZ][^aAeEiIoOuUyY][^bBcCdDfFgGhHjJkKlLmMnNpPqQrRsStTvVwWxXyYzZ]/)
                print
        }'
}

pseudogn() {
    # genere pseudo
    local mask="$1"

    # longueur automatique = longueur du mask
    local len="${#mask}"

    crunch "$len" "$len" abcdefghijklmnopqrstuvwxyz -t "$mask" \
    | grep -Ev '(.)\1\1' \
    | grep -Ei '^[^aeiouy]*[^aeiouy][aeiouy][^aeiouy]'
}

whoiam() {
    # presentation
    local text="Salut.

Moi c‚Äôest ${1:-user}.
Passionn√©e par l‚Äôinformatique, Linux et tout ce qui se bidouille avec curiosit√©.

J‚Äôaime comprendre comment les choses fonctionnent,
tester, casser, r√©parer,
et apprendre encore.

Arch, scripts, serveurs, un peu de magie dans le terminal,
et beaucoup d‚Äôenvie de progresser.

Bienvenue dans mon univers."
    local delay="${2:-0.05}"

    for (( i=0; i<${#text}; i++ )); do
        printf "%s""${text:$i:1}"
        sleep "$delay"
    done
    printf "\n"
}

typewriter() {
    # machine a ecrire
    [[ -z "$1" ]] && { echo "Usage: typewriter  <text> "; return 1; }
    local text="$1"
    local delay="${2:-0.05}"

    for (( i=0; i<${#text}; i++ )); do
        printf "%s""${text:$i:1}"
        sleep "$delay"
    done
    printf "\n"
}

mkcd() {
    # creer un dossier et va dedans
    mkdir -p "$1" && cd "$1"
     
}

backthis() {
    # fais un backup
    cp "$1" "$1.$(date +%Y%m%d%H%M%S).bak"

}

sshkg() {
    # genere une cle ssh
    local fname="id_ed_"$1"_$(for i in {1..5}; do printf "\\$(printf %o $(($RANDOM%26+97)))"; done)"
    ssh-keygen -f "$fname" -t ed25519 -N "" &> /dev/null
    echo "üîë Cl√© ED25519 cr√©√©e : $fname"
}

sshkg5() {
    # genere 5 cle ssh
    for i in 1 2 3 4 5; do
        fname="id_ed_$(date +%s)_$i"
        ssh-keygen -t ed25519 -f "$fname" -N "" &>/dev/null
        echo "üîë Cl√© ED25519 cr√©√©e : $fname"
    done
}

fuck() {
    # replay last commmand with sudo
    sudo $(fc -ln -1)

}

extract() {
    # fais un extract de fichier
    if [ -z "$1" ]; then
        echo "Usage: extract <fichier>"
        return 1
    elif [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1" ;;
            *.tar.gz)    tar xzf "$1" ;;
            *.tar.xz)    tar xJf "$1" ;;
            *.bz2)       bunzip2 "$1" ;;
            *.rar)       unrar x "$1" ;;
            *.gz)        gunzip "$1" ;;
            *.tar)       tar xf "$1" ;;
            *.zip)       unzip "$1" ;;
            *.7z)        7z x "$1" ;;
            *)           echo "Type de fichier non support√© : $1" ;;
        esac
    else
        echo "$1 n‚Äôest pas un fichier"
    fi
}

disable_ipv6() {
    # supprime ipv6 definitif
    local conn="$1"
    nmcli connection modify "$conn" ipv6.method disabled
    nmcli connection down "$conn" && nmcli connection up "$conn"
    echo "IPv6 d√©sactiv√© pour $conn üòè"
}

set_dns() {
    # set les dns
    local conn="$1"
    shift
    local dns="$*"
    nmcli connection modify "$conn" ipv4.dns "$dns" ipv4.ignore-auto-dns yes
    nmcli connection down "$conn" && nmcli connection up "$conn"
    echo "DNS pour $conn : $dns üíñ"
}

clean_tmp() {
    # rm les fichier tmp
    echo "üßπ Suppression fichiers temporaires..."
    rm -rf /tmp/*
    echo "‚úÖ Termin√©"
}

note() {
    # ecris dans notes.txt avec indent 
    [[ -z "$1" ]] && { echo "Usage: note <texte>"; return 1; }

    local date_now=$(date '+%Y-%m-%d %H:%M:%S')
    local separator="--------------------------------------"

    printf "\n%s\n\n%s\n%b\n" "$separator" "$date_now" "$1" >> ~/notes.txt
    echo "üìù Note ajout√©e"
}

mkvenv() {
    # creer et active un venv
    [[ -z "$1" ]] && { echo "Usage: mkvenv <nom_du_venv>"; return 1; }
    python3 -m venv "$1"
    source "$1/bin/activate"
    echo "üíñ Venv '$1' cr√©√© et activ√©"
}

actvenv() {
    # active un venv python
    [[ -z "$1" ]] && { echo "Usage: actvenv <nom_du_venv>"; return 1; }
    source "$1/bin/activate"
    echo "üíñ Venv '$1' activ√©"
}

rmvenv() {
    # supprime un venv python
    [[ -z "$1" ]] && { echo "Usage: rmvenv <nom_du_venv>"; return 1; }
    deactivate
    rm -rf "$1"
    echo "üóëÔ∏è Venv '$1' supprim√©"
}

search() {
    #search un truc dans tout fichier
    [[ -z "$1" ]] && { echo "Usage: search <mot>"; return 1; }
    grep -RIn --color=auto "$1" .
}

recentfiles() {
    # affiche les fichier recents
    [[ -z "$1" ]] && days=1 || days="$1"
    find . -type f -mtime -"${days}" -ls
}

msg() {
    #affiche un message 
    echo "\n\n\n"
    echo "$1" | cowsay -f tux | lolcat
    echo "\n\n"
}

myalias() {
    # retourne les alias
    echo "--------------------"
    echo "| üå∏ Mes Alias üå∏  |"
    echo "--------------------"
    # parcourt tous les alias
    alias | while IFS='=' read name cmd; do
        name="${name#alias }"
        echo "‚ú® $name ‚Üí ${cmd//'/}"
        echo ""
    done
}

myfonction() {
    # retourne les fonction
    echo ""
    echo "-----------------------------------------------"
    echo "|üå∏ Mes Fonctions d√©finies dans zsh_aliases üå∏|"
    echo "-----------------------------------------------"
    echo ""
    local myfile="$HOME/1_myconfig_arch/1_conf_term/.zsh_aliases"

    grep -E '^[a-zA-Z][a-zA-Z0-9]*\(\)[[:space:]]*\{' "$myfile" |
    while read -r line; do
        funcname="${line%%\(\)*}"
        funcname="${funcname// /}"

        desc=$(sed -n "/^$funcname()/,/^}/p" "$myfile" | sed '1d;$d' | head -1)

        echo "  üíñ $funcname() ‚Üí ${desc:-Pas de description}"
        echo ""
    done
}
